\section{Inside the layouts}
\label{sec:layouts}

For graph layout within an application, it is usually adequate to
invoke the top-level entry point, such as {\tt dot\_layout}. In
certain cases, though, an application may wish to impose finer
control on the layout process, or avoid certain steps which are
irrelevant to its presentation. For these reasons, this section
describes the individual passes used within each algorithm. 

Here, we will assume that the graph is connected. 
All of the layouts handle unconnected graphs. Sometimes, though,
an application may not want to use the built-in
technique. For these cases, \gviz\ provides tools for 
decomposing a graph, and then
combining multiple layouts. This is describedin Section~\ref{sec:unconnect}.

In all of algorithms, the first step is to call a layout-specific
{\tt init\_graph} function. For example, in the case of \dot, we
call {\tt dot\_init\_graph}). These functions 
initialize the graph for the particular algorithm.
This will first call common routines to set up basic data structures,
especially those related to the final layout results and
code generation. In particular, the size and shape of nodes will
have been analyzed and set at this point, which the application
can access via the {\tt ND\_width}, {\tt ND\_height}, 
{\tt ND\_ht}, {\tt ND\_lw}, 
{\tt ND\_rw}, {\tt ND\_shape}, {\tt ND\_shape\_info}
and {\tt ND\_label} attributes.
Initialization will then establish the data
structures specific to the given algorithm. Both the generic
and specific layout resources are released when the corresponding
cleanup function (e.g., {\tt dot\_cleanup}) is called (cf. Section~\ref{sec:clean}).
As a rule, a layout's {\tt init\_graph} routine should always be paired
with its {\tt cleanup} funtion. The former guarantees correctly
allocated and initialized data structures, while the latter releases
the allocated space, preventing memory leaks.

A layout algorithm will typically set low-level parameters in its
{\tt init\_graph} function, converting the string-valued parameters
specified in the graph. Thus, if an application insists on setting the
field in a data structure directly, it should only do this after the graph
is initialized. If done earlier, there is a chance the value will be
overridden by the initialization routine.

Almost always, the penultimate step is to generate the edges. As this may
be expensive to compute and irrelevant to an application, this is one
call an application may decide to avoid. Obviously, if this function is
not called, the application should not expect any edge position information.
On the other hand, it should be safe to call {\tt dotneato\_postprocess}
or the \gviz\ renderers.

The \dot\ algorithm has its own special function {\tt dot\_splines}
for handling edge generation. Its algorithm allows it to integrate
edge placement with node layout. Most of the other layouts make a call
to {\tt spline\_edges}, which uses the \gviz\ path planning library
to generate spline for edges if required. The only exception is
\fdp, which calls {\tt spline\_edges0} instead. This avoids some initial
calculations in{\tt spline\_edges} which are unnecessary in \fdp.

The algorithms all end with {\tt dotneato\_postprocess}.
The role of this function is to do some final tinkering with the
layout, still in layout coordinates. Specifically, the function
rotates the layout for \dot\ if {\tt rankdir}) is set,
attaches the root graph's label, if any, and normalizes the drawing
so that the lower left corner of its bounding box is at the origin. In
addition to the graph, the function takes an algorithm-specific
function used for setting node sizes. Each algorithm has defined
one of these.

\subsection{\dot}

The \dot\ algorithm produces a ranked layout of a graph honoring
edge directions if possible. It is particularly appropriate for displaying
hierarchies or directed acyclic graphs. The basic layout scheme
is attributed to Sugiyama et al.\cite{stt} The specific algorithm
used by \dot\ follows the steps described by Gansner et al.\cite{gknv:methods}

\begin{verbatim}
    dot_init_graph(g);
    dot_rank(g);
    dot_mincross(g);
    dot_position(g);
    dot_sameports(g);
    dot_splines(g);
    dot_compoundEdges (g);
    dotneato_postprocess(g, dot_nodesize);
\end{verbatim}

After graph initialization ({\tt dot\_init\_graph}), the algorithm
assigns each node to a discrete rank ({\tt dot\_rank})
using an integer program to minimize the sum of the (discrete) edge lengths. 
The next step ({\tt dot\_mincross}) rearranges nodes within ranks to
reduce edge crossings. This is followed by the assignment ({\tt dot\_position})
of actual coordinates to the nodes, using another integer program to
compact the graph and straighten edges. At this point, all nodes will
have a position set in the {\tt coord} attribute. In addition, the
bounding box {\tt bb} attribute of all clusters are set.

The {\tt dot\_sameports} step
is an addition to the basic layout. It
implements the feature, based on the edge attributes {\tt "samehead"}
and {\tt "sametail"}, by which certain edges sharing a node all connect
to the node at the same point.

To generate edge representations, the application can call {\tt dot\_splines}.
At present, \dot\ draws all edges as B-splines, though some edges will
actually be the degenerate case of a line segment.

Although \dot\ supports the notion of cluster subgraphs, its model does
not correspond to general compound graphs. In particular, a graph cannot
have have edges connecting two clusters, or a cluster and a node. The
layout can emulate this feature. Basically, if the head and tail nodes
of an edge lie in different, non-nested clusters, the edge can specify
these clusters as a logical head or logical tail using the {\tt lhead} or 
{\tt ltail} attribute. The
spline generated in {\tt dot\_splines} for the edge can then be clipped
to the bounding box of the specified clusters.  

\subsection{\neato}
\label{sec:neato}

The layout computed by \neato\ is specified by a virtual physical
model, i.e., one in which nodes are treated as physical objects
influenced by forces, some of which arise from the edges in the
graph. The layout is then derived by finding positions of the nodes
which minimize the forces or total energy within the system.
The forces need not correspond to true physical forces, and typically
the solution represents some local minimum. 
Such layouts are sometimes referred to as symmetric, as the
principal aesthetics of such layouts tend to be the visualization
of geometric symmetries within the graph. To further enhance the
display of symmetries, such drawings tend to use line segments for edges.

The model used by \neato comes from Kamada and Kawai\cite{kk}, 
though it was first introduced by Kruskal and Seely\cite{kruskal} in a 
different format. 
The model assumes there is a spring between
every pair of vertices, each with an ideal length. The ideal lengths
are a function of the graph edges. The layout attempts to minimize the
energy in this system.

\begin{verbatim}
    neato_init_graph(g);
    neatoLayout (g, layoutMode, model); 
    adjustNodes(g);
    spline_edges(g);
    dotneato_postprocess(g, neato_nodesize);
\end{verbatim}

As usual, we start with a call to {\tt neato\_init\_graph}.
former function is that the dimension of the layout $Ndim$ is determined from
the graph's {\tt "dim"} attribute, with the default being 
a two-dimensional layout. 

The call to actually perform the layout requires 2 additional parameters
to specify both the mode and the distance model used. 
If one uses {\tt layoutMode = MODE\_MAJOR}, which is what \neato\ uses
by default, the optimization is performed by stress majorization\cite{gkn}.
If one uses {\tt layoutMode = MODE\_KK}, the algorithm employs the
solution technique proposed by Kamada and Kawai\cite{kk}.
The latter mode is typically slower than the former, and introduces the
possibility of cycling. It is maintained solely for backward compatibility.

The model indicates how the ideal distances are computed between all
pairs of nodes.  Usually, \neato\
uses a shortest path model ({\tt model = MODEL\_SHORTPATH}),
so that the length of the spring between
nodes $p$ and $q$ is the length of the shortest path between them
in the graph. Note that the shortest path calculation takes
into account the lengths of edges as specified by the {\tt "len"}
attribute, with one inch being the default. 

If {\tt MODE\_KK} is used and the graph attribute {\tt pack} is false, 
\neato\ sets the distance between nodes in separate connected components
to $1.0 + L_{avg}\cdot\sqrt{|{\tt V}|}$, 
where $L_{avg}$ is the average edge length and $|{\tt V}|$
is the number of nodes in the graph.
This supplies sufficient separation between components
so that they do not overlap. Typically, the larger components will be
centrally located, while smaller components will form a ring around
the outside.

In some cases, an application may decide to use circuit model
({\tt model = MODEL\_CIRCUIT}),
a model based on electrical circuits 
as first proposed by Cohen\cite{cohen}. 
In this model, the spring length is derived from resistances using
Kirchoff's law. This means that the more paths between  $p$ and $q$
in the graph, the smaller the spring length. This has the effect of
pulling clusters closer together.
We note that this approach only works if the graph is connected.
If the graph is not connected, the layout automatically reverts to the
shortest path model.

The third model is the subset model ({\tt model = MODEL\_SUBSET}).
This sets the length of each edge to be the number of nodes that are 
neighbors of exactly one of the end points, and then calculates 
remaining distances using shortest paths. This helps to separate 
nodes with high degree. 

The library provides two utility functions
\begin{verbatim}
    int neatoMode (Agraph_t* g);
    int neatoModel (Agraph_t* g);
\end{verbatim}
which can be used to query the graph attributes {\tt mode} and {\tt model},
respectively, and return the corresponding mode and model integer values.

The basic algorithm used by \neato\ performs the layout assuming
point nodes. Since in many cases, the final drawing uses text
labels and various node shapes, the drawing ends up with many
nodes overlapping each other. For certain uses, the effect is
desirable. If not, the application can use {\tt adjustNodes} to
reposition the nodes to eliminate overlaps. There are 2 methods
available, depending on the graph attribute {\tt "overlap"}.
One\cite{voronoi} uses a Voronoi-diagram based approach, 
which requires the least
additional space, but can greatly distort the original layout. At
the other extreme, {\tt adjustNodes} allows scaling\cite{scale}. This exactly
preserves the shape of the layout but at the expense of much space.
We note the obvious fact that, in both methods, the nodes sizes 
are preserved; only the node positions are altered.

With nodes positioned, the algorithm can proceed to draw the
edges using the {\tt spline\_edges} function. 
By default, edges are drawn as line
segments. If, however, the {\tt "splines"} graph attribute is
set to true, {\tt spline\_edges} will construct the edges as
splines\cite{paths}, 
routing them around the nodes. Topologically, the spline
follows the shortest path between two nodes while avoiding all others.
Clearly, for this to work, there can be no node overlaps. If overlaps
exist, edge creation reverts back to line segments.
When this function returns, the positions of the nodes will be recorded
in their {\tt coords} attribute, in points.

The programmer should be aware of certain limitations and
problems with the \neato\ algorithm. 
First, as noted above, if {\tt layoutMode = MODE\_KK}, 
it is possible for the minimization technique used by \neato\
to cycle, never finishing. At present, there
is no way for the library to detect this, though once identified,
it can easily be fixed by simply picking another initial position.
Second, although multiedges affect the layout,
the spline router {\tt spline\_edges} does not handle them. Thus,
two edges between the same nodes will receive the same spline.
Finally, \neato\ provides no mechanism for drawing clusters. 
If clusters are required, one should use the \fdp\ algorithm, which belongs
to the same family as \neato\ and is described next.

\subsection{\fdp}
\label{sec:fdp}

The \fdp\ layout is similar in appearance to \neato\ and also relies
on a virtual physical model, this time proposed by Fruchterman and
Reingold\cite{fr}. This model uses springs only between nodes
connected with an edge, and an electrical repulsive force between
all pairs of nodes. Also, it achieves a layout by minimizing the forces
rather than energy of the system.

Unlike \neato, \fdp\ supports cluster subgraphs. In addition, it
allows edges between clusters and nodes, and between cluster and clusters.
At present, an edge from a cluster cannot connect to a node or cluster
with the cluster.

\begin{verbatim}
    fdp_init_graph (g);
    fdpLayout (g);
    spline_edges0(g);
    dotneato_postprocess(g, neato_nodesize);
\end{verbatim}

The layout scheme is fairly simple: initialization; layout; a call to
route the edges; and postprocessing. In \fdp, because it is necessary
to keep clusters separate, the removal of overlaps is (usually)
obligatory and there is no explicit call to {\tt adjustNodes}.

\subsection{\twopi}
\label{sec:twopi}

The radial layout algorithm represented by {\tt twopi} is conceptually the 
simplest in \gviz. Following an algorithm described by Wills\cite{nicheworks},
it takes a node specified as the center of the layout and the root
of the generated spanning tree. The remaining
nodes are placed on a series of concentric circles about the center,
the circle used corresponding to the graph-theoretic distance from the
node to the center. Thus, for example, all of the neighbors of the
center node are placed on the first circle around the center.
The algorithm allocates angular slices to each branch of the 
induced spanning tree to guarantee enough space for the tree on each ring.

It should be obvious from the description that the basic version of
the \twopi\ algorithm relies on the graph being connected. If this
is not the case, the application can use the technique described
in Section~\ref{sec:unconnect}.
At present, the algorithm does not attempt to visualize clusters.

\begin{verbatim}
    Agnode_t*  ctr;      /* center node of layout */

    twopi_init_graph(g);
    circleLayout (g,ctr);
    adjustNodes (g);
    spline_edges(g);
    dotneato_postprocess(g, twopi_nodesize);
\end{verbatim}

As usual, the layout commences by initializing the graph 
({\tt twopi\_init\_graph}). The entire layout is handled by a call
to {\tt circleLayout}. Note that it is up to the application to supply
a center node. If {\tt ctr == NULL}, the algorithm will select some
``most central'' node, i.e., one whose minimum distance from a leaf
node is maximal. Upon the function's return, the x and y coordinates of
the node can be found, in inches, in the 
attributes {\tt pos[0]} and {\tt pos[1]}, respectively.

As with \neato, if the application invokes {\tt adjustNodes}, 
the library will, if specified, adjust the layout to avoid node-node
overlaps. Again as with \neato, a call to 
{\tt spline\_edges} will compute drawing information for edges. See
Section~\ref{sec:neato} for more details.

\subsection{\circo}
\label{sec:circo}

The\circo\ algorithm is based on the work of Six and Tollis\cite{st,st2},
as modified by Kaufmann and Wiese\cite{kw}. The nodes in each 
biconnected component are placed on a circle, with some attempt to 
minimize edge crossings. Then, by considering each component as a single
node, the derived tree is laid out in a similar fashion to \twopi,
with some component considered as the root node.

\begin{verbatim}
    circo_init_graph(g);
    circoLayout(g);
    spline_edges(g);
    dotneato_postprocess(g, circo_nodesize);
\end{verbatim}

As with \fdp, the scheme is very simple.
By construction, the \circo\ layout avoids node overlaps, so no use
{\tt adjustNodes} is necessary.

