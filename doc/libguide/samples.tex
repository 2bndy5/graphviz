\section{A sample program: {\tt simple.c}}
\label{sec:simple}
This following code illustrates an application which only uses \gviz\ to
position a graph. The application will either provide its own
rendering, perhaps in an interactive setting, or, as in this
case, it does not render the graph at all.
\pagebreak[4]
\begin{verbatim}
#include <dotneato.h>

int main(int argc, char** argv)
{
    Agraph_t* g;
    Agnode_t* n;
    FILE*     fp;
    char      buf[BUFSIZ];
    point     p;

    aginit ();

    if (argc > 1)
        fp = fopen (argv[1],"r");
    else
        fp = stdin;
    g = agread (fp);

    dot_layout(g);
    
    agnodeattr(g, "pos", "");
    for (n = agfstnode(g); n; n = agnxtnode(g,n)) {
        p = ND_coord_i(n);
        sprintf(buf,"%d,%d", p.x, p.y);
        agset(n,"pos",buf);
        printf ("node %s at position (%s)\n", n->name, buf);
    }
    agwrite(g, stdout);

    dot_cleanup(g);
    return 0;
}	
\end{verbatim}

\section{A sample program: {\tt dot.c}}
\label{sec:dot}
This example shows how an application might read a stream of input graphs,
lay out each, and then use the \gviz\ renderers to write the drawings
to an output file. Indeed, this
is precisely how the \dot\ program is written, ignoring some signal
handling, its specific declaration of 
the {\tt Info} data (cf. Section~\ref{sec:info}), and a few other
minor details.
If someone desired to write a new layout algorithm, this
code could be copied directly, merely changing the algorithm-specific 
layout and cleanup functions \verb+dot_layout+ and \verb+dot_cleanup+.
A more detailed and realistic example is provided in Appendix~\ref{sec:demo}.

\begin{verbatim}
#include <dotneato.h>

int main(int argc, char** argv)
{
    Agraph_t *g, *prev=NULL;
    GVC_t *gvc;

    gvc = gvContext();

    dotneato_initialize(gvc,argc,argv);
    while ((g = next_input_graph())) {
        if (prev) {
            dot_cleanup(prev);
            agclose(prev);
        }
        prev = g;

        gvBindContext(gvc, g);

        dot_layout(g);
        dotneato_write(gvc);
    }
    dotneato_terminate(gvc);
    return 0;
}
\end{verbatim}

\section{A sample program: {\tt demo.c}}
\label{sec:demo}
This example provides a modification of the previous example. Again it
relies on the \gviz\ renderers, but now it creates the graph dynamically
rather than reading the graph from a file.   
\begin{verbatim}
#include <dotneato.h>

int main(int argc, char** argv)
{
    Agraph_t *g;
    Agnode_t *n,*m;
    Agedge_t *e;
    Agsym_t  *a;
    GVC_t    *gvc;

    /* set up renderer context */
    gvc = gvContext();

    /* Accept -T and -o options like dot.
     * Input files are ignored in this demo. */
    dotneato_initialize(gvc, argc, argv);

    /* Create a simple digraph */
    g = agopen("g",AGDIGRAPH);
    n = agnode(g,"n");
    m = agnode(g,"m");
    e = agedge(g,n,m);

    /* Set an attribute - in this case one that affects the visible rendering */
    if (!(a = agfindattr(g->proto->n, "color")))
        a = agnodeattr(g, "color", "");
    agxset(n, a->index, "red");

    /* bind graph to GV context - currently must be done before layout */
    gvBindContext(gvc,g);

    /* Compute a layout */
    neato_layout(g);

    /* Write the graph according to -T and -o options */
    dotneato_write(gvc);

    /* Clean out layout data */
    neato_cleanup(g);

    /* Free graph structures */
    agclose(g);

    /* Clean up output file and errors */
    dotneato_terminate(gvc);

    return 0;
}    
\end{verbatim}
