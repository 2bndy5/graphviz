/* $Id$ $Revision$ */
/* vim:set shiftwidth=4 ts=8: */

/**********************************************************
*      This software is part of the graphviz package      *
*                http://www.graphviz.org/                 *
*                                                         *
*            Copyright (c) 1994-2004 AT&T Corp.           *
*                and is licensed under the                *
*            Common Public License, Version 1.0           *
*                      by AT&T Corp.                      *
*                                                         *
*        Information and Software Systems Research        *
*              AT&T Research, Florham Park NJ             *
**********************************************************/

/* FIXME - incomplete replacement for codegen */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

#include "macros.h"
#include "const.h"

#include "gvplugin_render.h"
#include "gvcint.h"
#include "graph.h"
#include "types.h"		/* need the SVG font name schemes */

/* highlight flag */
#define HIGHLIGHT 1
#define NOHIGHLIGHT 0

typedef enum { FORMAT_TK, } format_type;

static char *tkgen_string(char *s)
{
    return s;
}

static void tkgen_print_color(GVJ_t * job, gvcolor_t color)
{
    switch (color.type) {
    case COLOR_STRING:
	gvdevice_fputs(job, color.u.string);
	break;
    case RGBA_BYTE:
	if (color.u.rgba[3] == 0) /* transparent */
	    gvdevice_fputs(job, "none");
	else
	    gvdevice_printf(job, "#%02x%02x%02x",
		color.u.rgba[0], color.u.rgba[1], color.u.rgba[2]);
	break;
    default:
	assert(0);		/* internal error */
    }
}

static void tkgen_print_tags(GVJ_t *job, int tag)
{
    char *ObjType;
    unsigned int ObjHandle;
    obj_state_t *obj = job->obj;

    switch (obj->emit_state) {
    case EMIT_NDRAW:
    case EMIT_NLABEL:
	ObjType = "node";
        ObjHandle = obj->u.n->handle;
	break;
    case EMIT_EDRAW:
    case EMIT_TDRAW:
    case EMIT_HDRAW:
    case EMIT_ELABEL:
    case EMIT_TLABEL:
    case EMIT_HLABEL:
	ObjType = "edge";
        ObjHandle = obj->u.e->handle;
	break;
    case EMIT_GDRAW:
    case EMIT_CDRAW:
    case EMIT_GLABEL:
    case EMIT_CLABEL:
	ObjType = "graph";
        ObjHandle = obj->u.g->handle;
	break;
    default:
	assert (0);
	break;
    }
    gvdevice_printf(job, " -tags %d%s%ld", tag, ObjType, ObjHandle);
}


static void tkgen_grstyle(GVJ_t * job, int filled)
{
#if 0
    obj_state_t *obj = job->obj;

    gvdevice_fputs(job, " style=\"fill:");
    if (filled)
	tkgen_print_color(job, obj->fillcolor);
    else
	gvdevice_fputs(job, "none");
    gvdevice_fputs(job, ";stroke:");
    tkgen_print_color(job, obj->pencolor);
    if (obj->penwidth != PENWIDTH_NORMAL)
	gvdevice_printf(job, ";stroke-width:%g", obj->penwidth);
    if (obj->pen == PEN_DASHED) {
	gvdevice_printf(job, ";stroke-dasharray:%s", sdarray);
    } else if (obj->pen == PEN_DOTTED) {
	gvdevice_printf(job, ";stroke-dasharray:%s", sdotarray);
    }
    gvdevice_fputs(job, ";\"");
#endif
}

static void tkgen_comment(GVJ_t * job, char *str)
{
    gvdevice_fputs(job, "# ");
    gvdevice_fputs(job, tkgen_string(str));
    gvdevice_fputs(job, "\n");
}

static void tkgen_begin_job(GVJ_t * job)
{
    gvdevice_fputs(job, "# Generated by ");
    gvdevice_fputs(job, tkgen_string(job->common->info[0]));
    gvdevice_fputs(job, " version ");
    gvdevice_fputs(job, tkgen_string(job->common->info[1]));
    gvdevice_fputs(job, " (");
    gvdevice_fputs(job, tkgen_string(job->common->info[2]));
    gvdevice_fputs(job, ")\n#     For user: ");
    gvdevice_fputs(job, tkgen_string(job->common->user));
    gvdevice_fputs(job, "\n");
}

static void tkgen_begin_graph(GVJ_t * job)
{
    obj_state_t *obj = job->obj;

    gvdevice_fputs(job, "#");
    if (obj->u.g->name[0]) {
        gvdevice_fputs(job, " Title: ");
	gvdevice_fputs(job, tkgen_string(obj->u.g->name));
    }
    gvdevice_printf(job, " Pages: %d\n", job->pagesArraySize.x * job->pagesArraySize.y);
}

static void tkgen_textpara(GVJ_t * job, pointf p, textpara_t * para)
{
    obj_state_t *obj = job->obj;

    gvdevice_fputs(job, "$c create text");
    gvdevice_printf(job, " %d %d", ROUND(p.x), ROUND(p.y));
    gvdevice_fputs(job, " -text {");
    gvdevice_fputs(job, para->str);
    gvdevice_fputs(job, "}");
    gvdevice_fputs(job, " -fill ");
    tkgen_print_color(job, obj->pencolor);
    gvdevice_fputs(job, " -font {");
    gvdevice_fputs(job, para->fontname);
    gvdevice_printf(job, " %g}", para->fontsize);
    switch (para->just) {
    case 'l':
        gvdevice_fputs(job, " -anchor w");
        break;
    case 'r':
        gvdevice_fputs(job, " -anchor e");
        break;
    default:
    case 'n':
        break;
    }
    gvdevice_fputs(job, " -state disabled");
    tkgen_print_tags(job, NOHIGHLIGHT);
    gvdevice_fputs(job, "\n");
}

static void tkgen_ellipse(GVJ_t * job, pointf * A, int filled)
{
#if 0
    /* A[] contains 2 points: the center and corner. */
    gvdevice_fputs(job, "<ellipse");
    tkgen_grstyle(job, filled);
    gvdevice_printf(job, " cx=\"%g\" cy=\"%g\"", A[0].x, -A[0].y);
    gvdevice_printf(job, " rx=\"%g\" ry=\"%g\"",
	    A[1].x - A[0].x, A[1].y - A[0].y);
    gvdevice_fputs(job, "/>\n");
#endif
}

static void
tkgen_bezier(GVJ_t * job, pointf * A, int n, int arrow_at_start,
	      int arrow_at_end, int filled)
{
#if 0
    gvdevice_fputs(job, "<path");
    tkgen_grstyle(job, filled);
    gvdevice_fputs(job, " d=\"");
    tkgen_bzptarray(job, A, n);
    gvdevice_fputs(job, "\"/>\n");
#endif
}

static void tkgen_polygon(GVJ_t * job, pointf * A, int n, int filled)
{
    int i;

    gvdevice_fputs(job, "$c create polygon");
    for (i = 0; i < n; i++)
	gvdevice_printf(job, " %d %d", ROUND(A[i].x), ROUND(-A[i].y));
    gvdevice_fputs(job, " -state disabled");
    tkgen_print_tags(job, NOHIGHLIGHT);
    gvdevice_fputs(job, "\n");
}

static void tkgen_polyline(GVJ_t * job, pointf * A, int n)
{
#if 0
    int i;

    gvdevice_fputs(job, "<polyline");
    tkgen_grstyle(job, 0);
    gvdevice_fputs(job, " points=\"");
    for (i = 0; i < n; i++)
	gvdevice_printf(job, "%g,%g ", A[i].x, -A[i].y);
    gvdevice_fputs(job, "\"/>\n");
#endif
}

/* color names from http://www.w3.org/TR/SVG/types.html */
/* NB.  List must be LANG_C sorted */
static char *tkgen_knowncolors[] = {
    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure",
    "beige", "bisque", "black", "blanchedalmond", "blue",
    "blueviolet", "brown", "burlywood",
    "cadetblue", "chartreuse", "chocolate", "coral",
    "cornflowerblue", "cornsilk", "crimson", "cyan",
    "darkblue", "darkcyan", "darkgoldenrod", "darkgray",
    "darkgreen", "darkgrey", "darkkhaki", "darkmagenta",
    "darkolivegreen", "darkorange", "darkorchid", "darkred",
    "darksalmon", "darkseagreen", "darkslateblue", "darkslategray",
    "darkslategrey", "darkturquoise", "darkviolet", "deeppink",
    "deepskyblue", "dimgray", "dimgrey", "dodgerblue",
    "firebrick", "floralwhite", "forestgreen", "fuchsia",
    "gainsboro", "ghostwhite", "gold", "goldenrod", "gray",
    "green", "greenyellow", "grey",
    "honeydew", "hotpink", "indianred",
    "indigo", "ivory", "khaki",
    "lavender", "lavenderblush", "lawngreen", "lemonchiffon",
    "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow",
    "lightgray", "lightgreen", "lightgrey", "lightpink",
    "lightsalmon", "lightseagreen", "lightskyblue",
    "lightslategray", "lightslategrey", "lightsteelblue",
    "lightyellow", "lime", "limegreen", "linen",
    "magenta", "maroon", "mediumaquamarine", "mediumblue",
    "mediumorchid", "mediumpurple", "mediumseagreen",
    "mediumslateblue", "mediumspringgreen", "mediumturquoise",
    "mediumvioletred", "midnightblue", "mintcream",
    "mistyrose", "moccasin",
    "navajowhite", "navy", "oldlace",
    "olive", "olivedrab", "orange", "orangered", "orchid",
    "palegoldenrod", "palegreen", "paleturquoise",
    "palevioletred", "papayawhip", "peachpuff", "peru", "pink",
    "plum", "powderblue", "purple",
    "red", "rosybrown", "royalblue",
    "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell",
    "sienna", "silver", "skyblue", "slateblue", "slategray",
    "slategrey", "snow", "springgreen", "steelblue",
    "tan", "teal", "thistle", "tomato", "turquoise",
    "violet",
    "wheat", "white", "whitesmoke",
    "yellow", "yellowgreen"
};

gvrender_engine_t tkgen_engine = {
    tkgen_begin_job,
    0,				/* tkgen_end_job */
    tkgen_begin_graph,
    0,				/* tkgen_end_graph */
    0, 				/* tkgen_begin_layer */
    0, 				/* tkgen_end_layer */
    0, 				/* tkgen_begin_page */
    0, 				/* tkgen_end_page */
    0, 				/* tkgen_begin_cluster */
    0, 				/* tkgen_end_cluster */
    0,				/* tkgen_begin_nodes */
    0,				/* tkgen_end_nodes */
    0,				/* tkgen_begin_edges */
    0,				/* tkgen_end_edges */
    0,				/* tkgen_begin_node */
    0,				/* tkgen_end_node */
    0,				/* tkgen_begin_edge */
    0,				/* tkgen_end_edge */
    0,				/* tkgen_begin_anchor */
    0,				/* tkgen_end_anchor */
    tkgen_textpara,
    0,				/* tkgen_resolve_color */
    tkgen_ellipse,
    tkgen_polygon,
    tkgen_bezier,
    tkgen_polyline,
    tkgen_comment,
    0,				/* tkgen_library_shape */
};

gvrender_features_t render_features_tk = {
    GVRENDER_Y_GOES_DOWN,       /* flags */
    4.,                         /* default pad - graph units */
    tkgen_knowncolors,		/* knowncolors */
    sizeof(tkgen_knowncolors) / sizeof(char *),	/* sizeof knowncolors */
    RGBA_BYTE,			/* color_type */
};

gvdevice_features_t device_features_tk = {
    0,				/* flags */
    {0.,0.},			/* default margin - points */
    {0.,0.},                    /* default page width, height - points */
    {72.,72.},			/* default dpi */
};

gvplugin_installed_t gvrender_tk_types[] = {
    {FORMAT_TK, "tk", 1, &tkgen_engine, &render_features_tk},
    {0, NULL, 0, NULL, NULL}
};

gvplugin_installed_t gvdevice_tk_types[] = {
    {FORMAT_TK, "tk:tk", 1, NULL, &device_features_tk},
    {0, NULL, 0, NULL, NULL}
};
